<html><body><h3>find the longest palindrome in a string?</h3><p>['Microsoft', 'Amazon']</p><ul><hr/><li>
		<p>Actually, the most efficient algorithm is O(n) and is based on dynamic programming.</p>

<p>Let str be the string of length n.<br/>Let us define:<br/>len[i] = length of the longest palindrome in substring having characters str[0],str[1],...,str[i].<br/>beginIndex[i] = beginning index of the longest palindrome in substring having characters str[0],str[1],...,str[i].</p>

<p>len[0] = 1;<br/>beginIndex[0] = 0;<br/> <br/>Now, try to find out len[i] in terms of len[i-1] and beginIndex[i] in terms of beginIndex[i-1] - during this we should leglect the special case when all characters in palindromes are same. We should find maximum length palindrome of this type.</p>

<p>We should deal with the special case where all characters in palindromes are same separately and find the maximum length palindrome of such type.</p>

<p>Out of above two, we should pick the longer palindrome. More than enough to solve it.</p>

<p>In any case, full code is below:</p>

<p>public static String longestPalindrome(String str)<br/>	{<br/>		String result = ;<br/>		<br/>		int[] bIndex = new int[str.length()];<br/>		int[] len = new int[str.length()];<br/>		<br/>		int i = 0, j = 0, index = 0;<br/>		bIndex[0] = 0;<br/>		len[0] = 1;<br/>		if(str.charAt(0) == str.charAt(1))<br/>		{<br/>			bIndex[1] = 0;<br/>			len[1] = 2;<br/>		}<br/>		else<br/>		{<br/>			bIndex[1] = 1;<br/>			len[1] = 1;<br/>		}<br/>		<br/>		int maxLen = 0, bIndexMax = -1;<br/>		char c;<br/>		<br/>		for(i = 0; i  str.length(); i = j)<br/>		{<br/>			c = str.charAt(i);<br/>			for(j = i+1; j  str.length()  str.charAt(j) == c; j++);<br/>			if(maxLen  j-i)<br/>			{<br/>				maxLen = j-i;<br/>				bIndexMax = i;<br/>			}<br/>		}<br/>		<br/>		for(i = 2; i  bIndex.length; i++)<br/>		{<br/>			index = bIndex[i-1];<br/>			if( index == i-1)<br/>			{<br/>				if(str.charAt(i-2) == str.charAt(i))<br/>				{ // check for odd length palindrome<br/>					bIndex[i] = i-2;<br/>					len[i] = 3;<br/>				}<br/>				else if(str.charAt(i-1) == str.charAt(i))<br/>				{<br/>					bIndex[i] = i-1;<br/>					len[i] = 2;<br/>				}<br/>				else<br/>				{<br/>					bIndex[i] = i;<br/>					len[i] = 1;<br/>				}<br/>			}<br/>			else<br/>			{<br/>				if(index-1  0)<br/>				{<br/>					bIndex[i] = i;<br/>					len[i] = 1;<br/>				}<br/>				else if(str.charAt(index-1) == str.charAt(i))<br/>				{<br/>					bIndex[i] = index-1;<br/>					len[i] = len[i-1] + 2;<br/>				}<br/>				else<br/>					bIndex[i] = i;<br/>			}<br/>		}<br/>		<br/>		for(i = 0; i  len.length; i++)<br/>		{<br/>			if(maxLen  len[i])<br/>			{<br/>				maxLen = len[i];<br/>				bIndexMax = bIndex[i];<br/>			}<br/>		}<br/>		<br/>		<br/>		return str.substring(bIndexMax,bIndexMax + maxLen);<br/>		<br/>	}</p>

<p></p>
		</li><li style="margin-left:15px;">
		<p>code has bugs. how about abeeddddeabe?</p>
		</li><li style="margin-left:15px;">
		<p>not correct.</p>
		</li><hr/><li>
		<p>This self-contained C program will print out all of the palindrome lengths for all possible centers, and it will do it in O(n) time. It is a port of the algorithm in Haskell authored by Johan Jeuring here: johanjeuring.blogspot.com/2007/08/finding-palindromes.html</p>

<p><pre><br/>#include stdlib.h<br/>#include stdio.h<br/>#include string.h</p>

<p>// Simple linked list functions<br/>typedef struct Node Node;<br/>struct Node {<br/>  int len;<br/>  Node* next;<br/>};</p>

<p>Node* insertNode(Node* head, Node* node) {<br/>  node-next = head-next;<br/>  head-next = node;<br/>  return node;<br/>}</p>

<p>Node* createNode(int len) {<br/>  Node* newNode = (Node*) malloc(sizeof(Node));<br/>  newNode-len = len;<br/>  return newNode;<br/>}</p>

<p>Node* insertNum(Node* head, int len) {<br/>  return insertNode(head, createNode(len));<br/>}</p>

<p>void printReverse(Node* node) {<br/>  if (node != NULL) {<br/>    printReverse(node-next);<br/>    printf(%d , node-len);<br/>  }<br/>}</p>

<p>void printReverseList(Node* head) {<br/>  printReverse(head-next);<br/>  printf(\n);<br/>}</p>

<p>void cleanList(Node* head) {<br/>  Node* curr = head;<br/>  while (curr != NULL) {<br/>    Node* next = curr-next;<br/>    free(curr);<br/>    curr = next;<br/>  }<br/>}</p>

<p>int main(int argc, char* argv[]) {<br/>  if (argc  2) {<br/>    printf(USAGE: ./pal string\n);<br/>    return 0;<br/>  }<br/>  char* a = argv[1];<br/>  int n = 0;<br/>  int len = strlen(a);<br/>  int currTail = 0; // length of the longest tail palindrome<br/>  Node* centers = createNode(0);<br/>  centers-next = NULL;<br/>  while (n  len) {<br/>    if (n - currTail != 0  a[n - currTail - 1] == a[n]) {<br/>      n++;<br/>      currTail += 2;<br/>      continue;<br/>    }<br/>    Node* center = centers-next;<br/>    insertNum(centers, currTail);<br/>    int centerDist = currTail;<br/>    while (centerDist != 0  center != NULL  centerDist - 1 != center-len) {<br/>      centerDist--;<br/>      insertNum(centers, center-len  centerDist ? centerDist : center-len);<br/>      center = center-next;<br/>    }<br/>    if (centerDist == 0) {<br/>      n++;<br/>      currTail = 1;<br/>    } else {<br/>      currTail = center-len;<br/>    }<br/>  }<br/>  Node* center = centers-next;<br/>  insertNum(centers, currTail);<br/>  while (currTail != 0) {<br/>    currTail--;<br/>    insertNum(centers, center-len  currTail ? currTail : center-len);<br/>    center = center-next;<br/>  }<br/>  printReverseList(centers);<br/>  cleanList(centers);<br/>  return 0;<br/>}<br/></pre></p>
		</li><li style="margin-left:15px;">
		<p>@Ryan: Could you write some comments in the main function which would help to understand the algorithm.<br/>Link of Haskell code you provided is fine. Due to C/C++ background, I am neither able to understand its code nor the algo given there due to its complex explanation.</p>
		</li><hr/><li>
		<p>detalied explanation can be found at  www.math.tau.ac.il/~haimk/seminar02/suffixtrees.ppt</p>
		</li><li style="margin-left:15px;">
		<p><pre><br/>public class LongestPalindrom {<br/>	public static void main(String args[]) {<br/>		String str =  hello . you uoy era woh..;<br/>		char[] a = str.toCharArray();<br/>		int low = Integer.MAX_VALUE;<br/>		int upper = Integer.MIN_VALUE;<br/>		for (int i = 0; i  str.length(); i++) {<br/>			int start = i;<br/>			int end = i;<br/>			while (start = 0  end  str.length()) {<br/>				if (a[start] == a[end]) {<br/>					if (end - start  upper - low) {<br/>						upper = end;<br/>						low = start;<br/>					}<br/>					end++;<br/>					start--;<br/>				} else {<br/>					break;<br/>				}</p>

<p>}</p>

<p>}<br/>		for (int i = 0; i  str.length(); i++) {<br/>			int start = i;<br/>			int end = i + 1;<br/>			while (start = 0  end  str.length()) {<br/>				if (a[start] == a[end]) {<br/>					if (end - start  upper - low) {<br/>						upper = end;<br/>						low = start;<br/>					}<br/>					end++;<br/>					start--;<br/>				} else {<br/>					break;<br/>				}<br/>			}</p>

<p>}<br/>		for (int i = low; i = upper; i++) {<br/>			System.out.print(a[i]);<br/>		}<br/>	}</p>

<p>}<br/></pre></p>
		</li><hr/><li>
		<p>find palindrome in string A</p>

<p>reverse A as A, so its equivallent to find longest common substring between A and A?</p>

<p>if so, we can use prefix array method to do this as the pearls book suggested?</p>

<p></p>
		</li><li style="margin-left:15px;">
		<p>Not equivalent. Find comments below from Spec on Mar 10th.</p>
		</li><li style="margin-left:15px;">
		<p>The method is still feasible if we check the location of the common substrings after we find them. For the substring to be a palindrome, the start position of the substring in the original string should be symmetrical with the ending position of the substring in the reversed one.</p>
		</li><hr/><li>
		<p>You can use suffix tree or suffix array.</p>

<p>for(i=0;istrlen(A);i++)<br/>c[i]=A[i];<br/>for(i=0;istrlen(A);i++)<br/>c[i]=A[i];</p>

<p>for(i=0;istrlen(A);i++)<br/>{<br/>get the longest common substring from the head of<br/>c[i],c[n-i-1]<br/>c[i+1],c[n-i-1]<br/>}</p>
		</li><hr/><li>
		<p>This is a problem of finding the LCS(longest common subsequence ) between the string and the its reverse.</p>
		</li><li style="margin-left:15px;">
		<p>o what a</p>
		</li><hr/><li>
		<p>It is Longest Common Substring (Need to be contiguous)</p>
		</li><hr/><li>
		<p>This can be solved using Suffix Tree.</p>
		</li><hr/><li>
		<p>01234567890010987654321 will return 123456789</p>
		</li><li style="margin-left:15px;">
		<p>This counter example isnt correct. LCS of the string and reverse is abccba. Its a valid palindromic substring of the input.</p>
		</li><hr/><li>
		<p>Yes, LC String does not work.<br/>Ex: string:abcdecba<br/>   reverse:abcedcba<br/>       LCS:abc/cba</p>
		</li><li style="margin-left:15px;">
		<p>Very good counter example. Thanks.</p>
		</li><li style="margin-left:15px;">
		<p>I didnt understand: isnt abc/cba the longest palindromic substring for the ex.?</p>
		</li><li style="margin-left:15px;">
		<p>This counter example isnt correct. LCS of the string and reverse is abccba. Its a valid palindromic substring of the input.</p>
		</li><li style="margin-left:15px;">
		<p>Nope, it isnt.</p>
		</li><li style="margin-left:15px;">
		<p>IT is a valid example.. The palindromic substring is not contiguous</p>
		</li><li style="margin-left:15px;">
		<p>A. reverse string.<br/>B. get LC substrings. in this case ABC  CBA.<br/>C. check if they are palindromes. <br/>D. And thats it. <br/>Complexity is O (n^2). Lawyered.</p>
		</li><hr/><li>
		<p>1. Original string is A<br/>2. Reverse string is B<br/>3. Find common strings are C, D, E ....<br/>4. Find palindromic strings in step 3, suppose C, D.<br/>5. Find the max length of strings in step 4. Return.</p>
		</li><li style="margin-left:15px;">
		<p>awesome!</p>
		</li><li style="margin-left:15px;">
		<p>not awesome. that doesnt work.</p>
		</li><li style="margin-left:15px;">
		<p>it does work, but you have to find common string in this way:<br/>public static String FindCommonString(String str1, String str2)<br/>{<br/>	if(str1.length()!=str2.length()) return null;<br/>	StringBuilder sb=new StringBuilder();<br/>	for(int i=0;istr1.length();i++)<br/>	{<br/>			 if(str1.contains(str2.substring(i)))<br/>			{<br/>				sb.append(str2.substring(i));<br/>				break;<br/>			}<br/>		}</p>

<p>return sb.toString();</p>

<p>}</p>
		</li><li style="margin-left:15px;">
		<p>Needs some change of the code above:<br/>public static String FindCommonString(String str1, String str2)<br/>	{<br/>		if(str1.length()!=str2.length()) return null;<br/>		StringBuilder sb=new StringBuilder();<br/>		int maxLength=0;<br/>		for(int i=0;istr1.length();i++)<br/>		{<br/>			for(int j=0;jstr2.length();j++)<br/>			{<br/>				int compLength=str2.length()-j-i;<br/>				if(compLength=1)break;<br/>				if(str1.contains(str2.substring(i,str2.length()-j)))<br/>				{<br/>					//System.out.println(str2.substring(i,str2.length()-j));</p>

<p>if(compLengthmaxLength)<br/>					{<br/>						maxLength=compLength;<br/>						sb.append(str2.substring(i,str2.length()-j));<br/>						System.out.println(sb.toString());<br/>					}<br/>				}<br/>			}<br/>		}</p>

<p>return sb.toString();</p>

<p>}</p>
		</li><hr/><li>
		<p>Heres a solution in C++ (may not be the most effective, though). Basically it checks if the given string s is a palindrome. If it is, then thats the longest we can find.</p>

<p>If not a palindrome, look in s.substr(0, len - 1) and in s.substr(1, len - 1) and return the longest result.</p>

<p><pre><br/>#include cassert<br/>#include iostream<br/>#include string<br/>#include utility<br/>using namespace std;</p>

<p>static size_t distance(const pairsize_t, size_t p)<br/>{<br/>    assert(p.first = p.second);<br/>    return p.second - p.first;<br/>}</p>

<p>//count how many times find_longest_palindrome is invoked<br/>static size_t count = 0;</p>

<p>static pairsize_t, size_t find_longest_palindrome(const char* s, size_t len)<br/>{<br/>    ++count;<br/>    pairsize_t, size_t result;</p>

<p>#if 0<br/>    //move outwards beginning from the middle<br/>    size_t i = len / 2, j = len / 2;<br/>    if (len  len % 2 == 0)<br/>    {<br/>        assert(i  0);<br/>        --i;<br/>    }<br/>    for (; j  len; ++j, --i)<br/>    {<br/>        assert(i  len);<br/>        if (s[i] != s[j])<br/>        {<br/>            break;<br/>        }<br/>        result.first = i;<br/>        result.second = j;<br/>    }<br/>    if (len  distance(result) + 1)  <br/>    {<br/>        //inspect right hand-side substring<br/>        pairsize_t, size_t result1 = find_longest_palindrome(s, len - 1);       <br/>        if (distance(result)  distance(result1))<br/>        {<br/>            result = result1;<br/>        }<br/>        //inspect right hand-side substring<br/>        pairsize_t, size_t result2 = find_longest_palindrome(s + 1, len - 1);<br/>        if (distance(result)  distance(result2))<br/>        {<br/>            result = result2;<br/>            ++result.first;<br/>            ++result.second;<br/>        }<br/>    }</p>

<p>#else<br/>    //work inwards from the extremities of the string<br/>    size_t i = 0, j = len ? len - 1 : 0;<br/>    result.first = 0;<br/>    result.second = j;<br/>    <br/>    for (; i  j; ++i, --j)<br/>    {<br/>        if (s[i] != s[j])<br/>        {<br/>            result.second = 0;<br/>            break;<br/>        }<br/>    }<br/>    if (!result.second  len  1)<br/>    {<br/>        //inspect right hand-side substring<br/>        result = find_longest_palindrome(s, len - 1);</p>

<p>//if the length found == len - 1 theres no point in inspecting<br/>        //the right hand substring<br/>        if (distance(result)  len - 1) <br/>        {<br/>            //inspect right hand-side substring<br/>            pairsize_t, size_t result2 = find_longest_palindrome(s + 1, len - 1);<br/>            if (distance(result)  distance(result2))<br/>            {<br/>                result.first = result2.first + 1;<br/>                result.second = result2.second + 1;<br/>            }<br/>        }<br/>    }<br/>#endif<br/>    return result;<br/>}</p>

<p>string find_longest_palindrome(const string s)<br/>{<br/>    count = 0;<br/>    pairsize_t, size_t r = find_longest_palindrome(s.c_str(), s.length());<br/>#if _DEBUG<br/>    cout  [  r.first  ,   r.second  ]  endl;<br/>    cout  string length=  s.length()  , number of steps=  count  endl;<br/>#endif<br/>    return distance(r) ? s.substr(r.first, distance(r) + 1) : string();<br/>}</p>

<p>void main()<br/>{<br/>    cout  find_longest_palindrome(abcd)  endl;<br/>    cout  find_longest_palindrome(xxbaaba)  endl;<br/>    cout  find_longest_palindrome(xxbaabaa)  endl;<br/>    cout  find_longest_palindrome(xxba)  endl;<br/>    cout  find_longest_palindrome(yyyba)  endl;<br/>    cout  find_longest_palindrome(xxbaabaawowaabx)  endl;<br/>}<br/></pre></p>
		</li><li style="margin-left:15px;">
		<p>yeah ok, like this is what you will write on a white board.  How many whiteboards will you need?  Get realistic.</p>
		</li><hr/><li>
		<p>http://wiki.answers.com/Q/Is_there_any_way_to_find_the_largest_palindrome_in_a_string</p>
		</li><hr/><li>
		<p>1) Naive algorithm finds he solution for the problem in O(n3) time.<br/>Select two ends to define a substring and check in linear time whether it is a palindrome.</p>

<p>2)Enhancement can be done to the naive algorithm to make it work in O(n2) time and O(n) space.<br/>Consider two strings  S and S(reverse). <br/>for each character in first string:<br/>for each subpattern in first string match the pattern in second string by KMP algorithm to find longest common string in both in linear time O(n+n) and O(n) space(this will be the palindrome).<br/>overall runtime O(n2) and O(n) space.</p>

<p>3)The optimized version of the algorithm runs in O(n) time with suffix trees.</p>
		</li><hr/><li>
		<p>i think we can solve this using dynamic programing...</p>

<p>n is the length of str<br/>if(in){<br/>str[i]==str[n] i++,n--;store i,n;<br/>else<br/>call func with i+1,n<br/>call func with i,n-1<br/>}</p>

<p>i think u got my sol..</p>
		</li><hr/><li>
		<p>DP solution:</p>

<p>int F(char* a, int n)<br/>{<br/>  if(n==1) return 1;<br/>  <br/>  int k = F(a, n-1);<br/>  if(IsPalindrom(a, n-2k-2, n))<br/>    k++;</p>

<p>return k;<br/>}</p>

<p>thoughts?</p>
		</li><hr/><li>
		<p>?</p>
		</li><li style="margin-left:15px;">
		<p>first identify the non repeating characters in the string it cannot be the part of a palindrome unless br<br/>s[i-1]=s[i+1](otherwise we may get palindrome of size as long as i traverses..].so we need to search in s[0...i-1] and s[i+1...n-1].. i hope this may help reducing the problem into parts..</p>
		</li><li style="margin-left:15px;">
		<p>first identify the non repeating characters in the string it cannot be the part of a palindrome unless br<br/>s[i-1]=s[i+1](otherwise we may get palindrome of size as long as i traverses..].so we need to search in s[0...i-1] and s[i+1...n-1].. i hope this may help reducing the problem into parts..</p>
		</li><hr/><li>
		<p>Just have an idea to reduce few calculations ..<br/>1. Maintain a hash table..keep track of all characters which appear more den once .( store their indices )<br/>2.You can chek for all these indices ..this will possible reduce chekin for all the possibilities ..waitin for a better soln :)</p>
		</li><hr/><li>
		<p>Agreed with sameerud, but essential addition: there are 2 types of palindromes:<br/>something like aba and abba.</p>

<p>So for every symbol we should test those two possibilities, not only the first one.</p>
		</li><hr/><li>
		<p>Agreed with sameerud, but essential addition: there are 2 types of palindromes:<br/>something like aba and abba.</p>

<p>So for every symbol we should test those two possibilities, not only the first one.</p>
		</li><hr/><li>
		<p>Input String is s1, Reverse the string to s2.<br/>Use Dynamic Programming to find the longest common substring. That gives u the result!</p>
		</li><li style="margin-left:15px;">
		<p>Okay genius, how about the string abcdefcba? The reverse is abcfedcba and the longest common substring is either abc or cba. Are those palindromes? Think about that.</p>
		</li><li style="margin-left:15px;">
		<p>Instead of DP, build a suffix tree and starting from longest common substring, find a palindrome.</p>
		</li><li style="margin-left:15px;">
		<p>longest common subsequence not substring</p>
		</li><hr/><li>
		<p>O(size(s1)+size(s2)) it is!</p>
		</li><hr/><li>
		<p>I kind of disagree from sameerud, because take an example of a string abcaba,,,<br/>so as i understand his algo. wont be able to find the pallindrome aba,, <br/>So, i there is one another algo</p>

<p>char *lar_pal = NULL;</p>

<p>char *str = /*some string*/<br/>for(int i=0;istrlen(str);i++){ //iterate over all of the string<br/>    for(int j=i+1;jstrlen(str);j++){</p>

<p>}</p>

<p>}</p>
		</li><hr/><li>
		<p>Sorry for previous reply,, pressed enter by mistake</p>

<p>I kind of disagree from sameerud, because take an example of a string abcaba,,,<br/>so as i understand his algo. wont be able to find the pallindrome aba,, <br/>So, i there is one another algo. (I should write sudo code)</p>

<p>1) Start from the first element i in the string and compare it will all other element j in the <br/>   string //for(j=i+1;jstrlen(somestr);j++)<br/>   a) if string[i] == string[j]<br/>            if(pallindrome(somestr,i,j)){<br/>                 //the substring is from i - j index<br/>            }<br/>   <br/>pallindrome(char *someStr, int i, int j)<br/>1) if someStr[i+1] == someStr[j-1]<br/>      if(i==j || i+1 == j)                    //aba,,,,abba  <br/>           return true<br/>      aii) else<br/>                i+=1;j-=1;<br/>                pallindrome(someStr,i,j)<br/>   else<br/>       return false</p>
		</li><hr/><li>
		<p>reverse + LCSubstring</p>
		</li><hr/><li>
		<p>This is a Longest Common Substring Problem,we basically construct the generalized suffix tree for the give string and its reverse.From the constructed tree it would be possible to find the longest Palindrome by traversing the tree.The construction of the tree would take O(n).</p>
		</li><li style="margin-left:15px;">
		<p>if the string is 123451254321 and we find the longest common substring with its reverse, the result would be 12345. But this doesnt seem right.</p>
		</li><li style="margin-left:15px;">
		<p>12345 is absolutely the longest palindrome in your string. Whats wrong with it?</p>
		</li><li style="margin-left:15px;">
		<p>@Anonymous 123451254321 when reversed would give 123452154321 ,so how do you say that the longest common palindrome would be 12345,unless you have a palindrome pattern in the main str ,its revers will not contain any palindrome.</p>

<p>For instance  This is the end here the longest palindrome is e e,upon reversing this string we get dne eht si siht  again the longest palindrome for this string is e e.So the longest common palindrome ends up being e e.In your example I dont see any such pattern.Correct me if i have mistaken your explanation/question.</p>
		</li><li style="margin-left:15px;">
		<p>how about is is ? I thought they were the longest palindrome...</p>
		</li><li style="margin-left:15px;">
		<p>Ok first,You need to know what a palindrome is MADAM when reversed still remains MADAM,likewise RACECAR when reversed gives RACECAR,Similarly EYE when reversed gives EYE.So A string is a palindrome only when its reverse also yields the same string.</p>

<p>@Vijgan This is the endreverse it what do you get</p>

<p>Original:This is the end<br/>Reversed:dne eht si siht ,so the longest palindrome cannot be si si,only if it was si is it is a palindrome.Hence here the longest palindrome would be e e.I hope this is clear.</p>
		</li><li style="margin-left:15px;">
		<p>@Vijgan:<br/>Moreover the longest common palindrome is one that is present in the exact same manner both in the original string and its reverse.In your case si si in the reversed string is present as is is in the original string.So this is not a palindrome at all.</p>
		</li><hr/><li>
		<p>My views:</p>

<p>1. Start with the middle element in the String (len/2). <br/>2. Have two pointers (i and j): i goes back till 0, j goes forward till n.<br/>3. whenever this fails : you have your longest palindrome.</p>

<p>This can be done other way too:</p>

<p>1. Have two pointers i and j at the beginning and at the end.</p>

<p>Like wise. Any takers?</p>
		</li><li style="margin-left:15px;">
		<p>Ur idea is good one...i successfully  implemented it ..thnx..order is O(n^2)</p>
		</li><li style="margin-left:15px;">
		<p>Ur idea is good one...i successfully  implemented it (of course with modifications but basic idea is as u said )... tested with tools and 100% working...now moving to suffix tree implementation....lets see how it goes...anyways thnx  raj..</p>
		</li><hr/><li>
		<p>I guess this is one of the best possible solution...<br/>But, usually this problem is coupled with another objective to find all the palindromes in a string and also to find the longest palindrome..in this case instead we can use a static variable and find the longest palindrome...</p>
		</li><hr/><li>
		<p>@particularraj: your algorithm works by the assumption that the palindrome starts in the middle of the string. It doesnt consider palindromes that at other places in the string. For example, consider the string<br/>ABMOCECXYYZ</p>

<p>Here according to your algorithm, you will start at E moving i backward and j forward. When i reaches O and j reaches X, the algorithm stops and concludes that CEC is the longest palindrome. But XYYZ is the longest palindrome in the above mentioned string.</p>
		</li><hr/><li>
		<p>The example string should be ABMOCECXYYX.</p>
		</li><hr/><li>
		<p>Nice comment KB. Then I guess I have no choice but to iterate it N times and update a static variable, so that we access and get the longest palindrome.</p>

<p>What do you think?</p>
		</li><hr/><li>
		<p>Create suffix trees of the original and reversed strings. Sort the suffixes separately. Find max length between suffix array from one string to that of the reversed.</p>
		</li><hr/><li>
		<p>Is there any O(n) solution other than suffix tree. I dont think the interviewer would ask you to construct a suffix tree during the interview.</p>
		</li><li style="margin-left:15px;">
		<p>The Sucker who was taking my interview did asked. I can bet he could have ever written that himself.</p>
		</li><hr/><li>
		<p>Suffix trees has O(n) time to look.</p>
		</li><hr/><li>
		<p>Suffix tree will give a very good solution, but it is difficult to come up in a interview. I would go with a dynamic programming approach,</p>

<p>Suppose we have the given string as,</p>

<p>InputString = abaccabadefg</p>

<p>Here there are 4 palindrome strings,<br/>aba - length 3<br/>cc - length 2<br/>aba - length 3<br/>abaccaba - length 8</p>

<p>Now the output should be abaccaba</p>

<p>In order to find that, reverse the input string,<br/>ReverseString = gfedabaccaba</p>

<p>Now create a 2 dimensional matrix of NxN and follow a dynamic program approach to get the length on the longest palindrome and display it. Heart of the solution is,</p>

<p>A[i,j] = Max (a[i-1, j], a[i,j-1] if InputString[i] != ReverseString[j]<br/>       = a[i-1,j-1] + 1, if InputString[i] == ReverseString[j]</p>
		</li><hr/><li>
		<p>How about having two pointers, one at the start and one at the end of the string.  For each character in the string, you will traverse backwards from the tail and try to find the largest possible palindrome matching with the start of the strong, if any.  You keep doing for every character, this until you find one, any palindrome.  Each time you do this loop for a character from the head, your largest palindrom will be s-n, where s is the original string length, and n is the number of iterations youve done this.  When you do find a palindrome, any palindrome, you will know that if the largest palindrome, it will be at between size (curr palindrom size) and (s-n).  Armed with this knowledge, you can then write a function that is optimized to only process the remainder of the array for strings that meet the stringlength described above.</p>

<p>And of course, this could be done elegantly using recursion, and fine tuning it with the logic similar to the above once you have confirmed at least one palindrome.  This of course is going to be a resource hog but the code will be easier to read and manage.</p>

<p>:)</p>
		</li><li style="margin-left:15px;">
		<p>good one !!! implemented successfully...100% working ...thnx</p>
		</li><hr/><li>
		<p>1. Find the reverse string<br/>2. Find longest common substring</p>

<p>Will this work? I think dynamic programming approach that you mentioned is same as this.</p>
		</li><li style="margin-left:15px;">
		<p>Even I feel the same.<br/>@Tejas<br/>Even though you said to use dynamic programming, your solutions major idea was to reverse the source string and find the common substring.<br/>Now take a look at this string abcdecba. If you reverse the string, you would get abc and cba as palindromes, which is incorrect.<br/>I hope only suffix trees would give an O(n) solution. Any other solution that we would give in an interview, would definitely be O(n^2) or higher(because a string with length n has n^2 substrings). Anybody disagrees with this statement guys??</p>
		</li><li style="margin-left:15px;">
		<p>Tell me if Im wrong, it will take O(n^3), right?</p>

<p>Loop structure could be something like following</p>

<p>i = 0 - n<br/>  j = i- n<br/>    k = j - n</p>
		</li><li style="margin-left:15px;">
		<p>Oops! I meant O(n^2)<br/>Loop structure will just be nested loops</p>

<p><pre><br/>i = 0 - n<br/>   j = i- n<br/></pre></p>
		</li><li style="margin-left:15px;">
		<p>It is not longest common substring .. it is longest common subsequence between the string and its reverse.</p>

<p>So for abcdecba, it will be abcdcba or abcecba</p>
		</li><hr/><li>
		<p>My cents:</p>

<p>Building suffix trees is not a bad idea. We can get that in O(nlogn) time.</p>
		</li><hr/><li>
		<p>Take a string</p>

<p>1. Reverse the string<br/>2. XOR with the Original String<br/>3. Find the longest sequence of 0s in the XORed result which will be the corresponding  answer</p>
		</li><li style="margin-left:15px;">
		<p>go suck dick</p>
		</li><li style="margin-left:15px;">
		<p>u 2</p>
		</li><li style="margin-left:15px;">
		<p>Hi Vishal,</p>

<p>You solution will not work always... You can try it on RACECAR........</p>
		</li><li style="margin-left:15px;">
		<p>reverse of RACECAR is RACECAR only .... so xoring dem wud giv 0000000 .... which is the longest palindrome ... i think vishals solution will work for all cases ...</p>
		</li><li style="margin-left:15px;">
		<p>reverse of RACECAR is RACECAR only .... so xoring dem wud giv 0000000 .... which is the longest palindrome ... i think vishals solution will work for all cases ...</p>
		</li><li style="margin-left:15px;">
		<p>that is an awesome approach.. guess it will work for all cases...<br/>small patch: if XORing is tough for charecters while coding... we can just subtract both the strings charecter by charecter... and then count the max no of consecutive zeros....</p>
		</li><li style="margin-left:15px;">
		<p>This wont work for HTTKNOM</p>
		</li><li style="margin-left:15px;">
		<p>this wont work for HTTKNOM</p>
		</li><li style="margin-left:15px;">
		<p>Stupid solution.</p>

<p>APQP<br/>PQPA</p>

<p>XOR, none are zeroes, but PQP is the longest palindrome.</p>
		</li><li style="margin-left:15px;">
		<p>You need to shifting windows to make this work:</p>

<p><pre><br/>def palindrome(string):<br/>    <br/>    Returns the longest palindrome in string.<br/>    <br/>    reverse = string[::-1]<br/>    winner = </p>

<p>if string == reverse:<br/>        return string</p>

<p>sources = [(string, reverse), (reverse, string)]</p>

<p>for source_a, source_b in sources:<br/>        for window in range(1, len(source_a) - 1):<br/>            string_a = source_a[:-window]<br/>            string_b = source_b[window:]</p>

<p>results = compare(string_a, string_b)<br/>            for result in results:<br/>                if len(result)  len(winner):<br/>                    winner = result</p>

<p>return winner</p>

<p>def compare(string_a, string_b):<br/>    <br/>    Compares two strings of equal length and finds any common strings between<br/>    the two.<br/>    <br/>    result = []<br/>    # True if a commonality is being extracted. This flag lets us know when to<br/>    # insert a new value into result.<br/>    found = False</p>

<p>for index in range(len(string_a)):<br/>        if string_a[index] == string_b[index]:<br/>            if not found:<br/>                result.append()<br/>                found = True<br/>            result[-1] += string_a[index]<br/>        else:<br/>            found = False</p>

<p>return result</p>

<p>from sys import argv<br/>print palindrome(argv[1])<br/></pre></p>
		</li><hr/><li>
		<p>start with the first character. try to lookup the same character from the bak. on finding the same character from the back check if the substring is palindrome or not. keep on finding the same character until u reach the index of the first character.</p>

<p>keep on doing the same for all the characters. ....O(n^2)</p>
		</li><li style="margin-left:15px;">
		<p>If im not mistaken wouldnt this be O(n^3)</p>
		</li><hr/><li>
		<p>Just reverse the string and find the largest substring in both the strings. O(n^2).</p>
		</li><hr/><li>
		<p>finding the longest substring of the string and its reverse wont work.  Consider<br/>abcdefgHELLOWORLDgfedcba  The longest palindrome is actually LL, that method would return abcdefggfedcba</p>
		</li><li style="margin-left:15px;">
		<p>the longest palindrome is infact OWO !!</p>
		</li><hr/><li>
		<p>Keep a current pointer on the second element a(1). place two other pointers at current-1 and current+1. check if curr-1 and curr+1 are equal. then move current pointer ahead. again set curr-1 and curr1 and check for:<br/>If curr is at ith position:<br/>while(i0)<br/>{<br/>if (curr-1 == curr+1) <br/>{<br/>   (curr+1)++;<br/>   (curr-1)--;<br/>    i--;<br/>}<br/>else break;<br/>}</p>

<p>keep tack of the largest one by storing the value of current for which the length of palindrome was max. also keep track of its length for each i. Then u can print the longest palindrome.</p>
		</li><li style="margin-left:15px;">
		<p>Its complexity will be O(n). I have a working code for this. if anybody want.</p>
		</li><li style="margin-left:15px;">
		<p>test case: abcddcbe</p>

<p>does it work?</p>
		</li><li style="margin-left:15px;">
		<p>No, It doesnot... because i assumed that palindrome will be of odd length...</p>

<p>For this case... place a current ptr and move the curr+ ptr till it goes to the value which is not equal to the current ptr. and then follow the steps above.</p>
		</li><li style="margin-left:15px;">
		<p>this looks like a good solution</p>
		</li><hr/><li>
		<p>@gagdeep what does the i signify ??</p>
		</li><hr/><li>
		<p>Can you show the working code by which you arrived O(n)</p>
		</li><hr/><li>
		<p>I think we cannot solve this question in less than O(n^3) complexity........as ideally there are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.</p>

<p>So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........</p>

<p>We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....</p>

<p>Seriously, I dont think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....</p>

<p>Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution...........</p>
		</li><hr/><li>
		<p><pre><br/>maxindex = 1;<br/>maxlen = 1;<br/>for(index = 1 to str.length) {<br/>  for(cur = 1 to min(index, abs(str.length - index))) {<br/>    if(str[index + cur] == str[index - cur]) {<br/>      if(cur  maxlen) continue;<br/>      maxlen = cur;<br/>      maxindex = index;<br/>    }<br/>  }<br/>}<br/></pre></p>

<p>May fail for the boundary conditions. But this the logic which i can think of for O(n2) complexity.<br/>We need two such code blocks one for even length and one for the odd length.<br/>Hence the time complexity is O(n2). O(1) space complexity</p>
		</li><hr/><li>
		<p>I am not sure about suffix tree, as I have not read those yet, but I dont think we can solve this question iteratively in less than O(n^3) and I dont think dynamic programming will work too as we cannot use the result that I got in previous iteration because if I have two strings that are palindrome then I cannot say that if I merge both string then those will be palindrome also...</p>

<p>Here is my solution using O(n^3) complexity.</p>

<p>There are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.</p>

<p>So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........</p>

<p>We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....</p>

<p>Seriously, I dont think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....</p>

<p>Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution...........</p>
		</li><hr/><li>
		<p>A working solution. O(n*n*n) complexity but good for an interview.</p>

<p><pre><br/>bool ispalindrome (const char * start, const char * end)<br/>{<br/>   while (start  end)<br/>   {<br/>      if (*start != *end)<br/>      {<br/>         return false;<br/>      }</p>

<p>start++;<br/>      end--;<br/>   }</p>

<p>return true;<br/>}</p>

<p>char * longestPalindrome(const char * str_p)<br/>{<br/>   int len = strlen (str_p);</p>

<p>const char * startOfPal = 0;  // start of palindrome.<br/>   const char * endOfPal = 0;    // end of palindrome.<br/>   int          maxLenOfPal = 0; // len of palindrome.</p>

<p>for (int i = 0; i  len; i++)<br/>   {<br/>      for (int j = len-1; j  i; j--)<br/>      {<br/>         const char * start = str_p + i;<br/>         const char * end = str_p + j;</p>

<p>if (ispalindrome(start, end))<br/>         {<br/>            if ((end - start + 1)  maxLenOfPal)<br/>            {<br/>               startOfPal = start;<br/>               endOfPal = end;<br/>               maxLenOfPal = end - start + 1;<br/>            }<br/>         }<br/>      }<br/>   }</p>

<p></pre></p>
		</li><hr/><li>
		<p>Not sure what happened to the white space.</p>

<p>Here is a quick test I used.</p>

<p><pre><br/>const char * str = testanaradaring;<br/>char * x = longestPalindrome(str);</p>

<p>if (x)<br/>{<br/>   cout  x  endl;<br/>}<br/>else<br/>{<br/>   cout  No palindrome found.  endl;<br/>}</p>

<p></pre></p>
		</li><li style="margin-left:15px;">
		<p>the simplest way is O(N^2)<br/>if applying suffix tree time can be reduced to O(NlogN)</p>
		</li><li style="margin-left:15px;">
		<p>the simplest way is O(N^2)<br/>if applying suffix tree time can be reduced to O(NlogN)</p>
		</li><hr/><li>
		<p>How about this way:<br/>1. define stringbulder variable called sb and an int called numberOfChars and max<br/>2. for each character in the string <br/>3. add the character to sb, and set numberOfChars to 1.     <br/>4. for each remaining character in the string<br/>5. append the character to sb and increment numberOfChars by 1.     <br/>6. if the character is the same as the character read in step 2, then what we have in sb is a potential palindrom so, call a helper funtion called IsPalindrome with the value in sb as an argument.<br/>7. If step 6 returns true, then add the content of sb to a dictionary with sb as a key and numberOfChars as a value---you can have duplicate checks<br/>8. inner loop ends here<br/>9. if numberOfChars  max then reset max to numberOfChars and clear sb<br/>9. loop to the first loop.<br/>10. Now, all possible palindrome strings are in your dictionary. Return a key with value equal to max.</p>

<p>Note that:<br/>The algorithm generates all possible palindroms but, i think there might be a better way of doing it.</p>

<p></p>
		</li><hr/><li>
		<p>Longest thread of answers to Longest palindrome finding :)</p>
		</li><hr/><li>
		<p>could not post the link. google for this. the first link has a good solution</p>

<p>finding-the-longest-palindromic-substring-in-linear-time.</p>
		</li><hr/><li>
		<p>Its awesome to see people using suffix tree and O(nlogn) at the same time !!</p>
		</li><li style="margin-left:15px;">
		<p>And why not?</p>

<p>There are simpler implementations of suffix tree which are O(nlogn).</p>

<p>Because implementing suffix tree can be so complex, ppl might choose to lose some run time over the possible maintenance headaches.</p>
		</li><hr/><li>
		<p>My suggestion is that any approach of O(n^2) time and O(1) space that can be well explained and you can write working code during an interview would suffice!</p>
		</li><hr/><li>
		<p>Reverse the string and find biggest substring.</p>
		</li><li style="margin-left:15px;">
		<p>Precisely. One moethod is what anonymous quoted. reverse and find the longest common substring. O(n2) method.</p>

<p>Second could be for every possible position in the string find the palindrome and keep track of the max found so far. One also has to take care of odd length and even length strings. <br/>AGain O(n2) method.</p>

<p></p>
		</li><hr/><li>
		<p>No need for such complex algorithms !!!</p>

<p>I was asked this question, I proposed trying all combination (O(n^2) I think) he looked convinced with that approach.</p>
		</li><hr/><li>
		<p>Example:<br/>================<br/>Str1=abcbabcmoms</p>

<p>Str2=abcba</p>

<p>ALGO:<br/>================<br/>1.a          take A[i]==A[j] , decrement J-- till i <br/>                if A[i]==A[j]<br/>                take paldromeindex=i<br/>                and increment i and decrement j till i=j<br/>                RANGE[k]=J-I<br/>                <br/>1.b          sort range and return the longest one</p>

<p>CODE:<br/>================</p>

<p>private string LongestPalindrom(Str S1,int size)<br/>{<br/>int maxrange =0;</p>

<p>For(int i=0;isize ; i++)<br/>                {<br/>                char ch1=s1[i];<br/>                                <br/>                                FOR(INT J=SIZE; J0;J--)                <br/>                                {<br/>                                char ch2=s1[j];</p>

<p>IF(CH1==CH2  i!=j)<br/>                                                {<br/>                                                 int range= j-i;<br/>                                                 i++;<br/>                                                 ch1=s1[i];<br/>                                                }<br/>                                }</p>

<p>IF(MAXRANGERANGE)<br/>                                {<br/>                                int maxrange =range;<br/>                        int maxindex=i<br/>                                }<br/>                }</p>

<p>FOR(k=maxindex;ki+maxrange;K++)   \\Printing the Longest Palindrome<br/>                                {<br/>                                 Console.writeline(Str[k]);           <br/>                                }</p>

<p>}</p>

<p>TEST HARNESS:<br/>================<br/>using system;</p>

<p>namespace problem<br/>{<br/>                class Solution<br/>                {<br/>                   static void Main(string[] args)<br/>                {<br/>                                 String Pal1 =abcbabcmoms<br/>                                 String Result;<br/>                                 Result= Longestpalindrom(Pal1,11);<br/>}}}</p>

<p>ORDER:<br/>================<br/>O(N^2)</p>
		</li><hr/><li>
		<p>Tarun,<br/>Nice try but you need more temp variables to save indexes and values. Try this string and you will find a bunch of bugs in ur code.<br/>BBABTENETTENEB.</p>

<p>This is is the code i came up with, can you guys please review it:</p>

<p>void longestPalindrome(char* str, int size, int* begin, int* range){<br/>     *begin = 0;<br/>     *range = 0;<br/>     int i, j, pali, tempRange = 0;<br/>     for(i = 0; i  size; i++){<br/>           *begin = pali = i;<br/>           for(j = size - 1; j = pali; j--){<br/>                 tempRange = j - *begin;<br/>                 if(str[pali] == str[j]){<br/>                      pali++;<br/>                 }else{<br/>                      tempRange = 0;<br/>                      if(pali != *begin){<br/>                          break;    <br/>                      } <br/>                 }      <br/>           }<br/>           if(*range  tempRange){<br/>               *range = tempRange;                <br/>           }      <br/>     }<br/>}</p>
		</li><hr/><li>
		<p><pre><br/>int main()<br/>{<br/>char a[]=abcdaeeadabb;<br/>char *p,*q,*r,*found;<br/>int i=0;<br/>int max=0;<br/>for(p=a;*p!=\0;p++)<br/>{<br/>q=p; r=a+strlen(a);<br/>    while(qr)<br/>    {<br/>    if(*q==*r)<br/>        {i+=2;<br/>        q++; r--;<br/>        }<br/>    else<br/>        {<br/>        i=0;<br/>        r--; q=p;<br/>        }<br/>    }<br/>    <br/>if(imax) {max=i; found=p;}<br/>}<br/>if(q==r) max=max+1;<br/>std::coutmax*found;<br/>return 0;<br/>}</p>

<p></pre></p>
		</li><hr/><li>
		<p><pre><br/>void longestPalindrome(char *str, int n)</p>

<p>{</p>

<p>int i=0, j=0, start = 0, end = 0, range = 0, maxstart = 0,maxend = 0;</p>

<p>while(i  n  j  n)</p>

<p>{</p>

<p>start = i; end = j;</p>

<p>while((str[start] == str[end])  (start =0)  (end = n))</p>

<p>{</p>

<p>if((maxEnd - maxStart)  (end-start))</p>

<p>{</p>

<p>maxEnd = end;</p>

<p>maxStart = start;</p>

<p>}</p>

<p>end++;</p>

<p>start--;</p>

<p>}</p>

<p>start++;</p>

<p>end++;</p>

<p>}</p>

<p>for(int i = maxStart; i = maxEnd; i++)</p>

<p>printf(%c, str[i]);</p>

<p>}<br/></pre></p>
		</li><hr/><li>
		<p>This is indeed a Dynamic Programming problem as Gopal Krishna has indicated but I cant think of a a solution that can solve this in less than O(n2).</p>

<p>My O(n2) solution was to take the string and its reverse (i.e. output of strrev(string)) and do a longest sub-string match using dynamic programing. The largest sub-string match is the longest palindrome in the given string.</p>
		</li><hr/><li>
		<p>pre lang=c# line=1 title=CodeMonkey63324 class=run-thisusing System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Text;<br/>using System.Collections;</p>

<p>class Program<br/>{<br/>static void Main(string[] args)<br/>{<br/>Program p = new Program();<br/>Console.WriteLine(p.LargestPalindrome(abbac);<br/>}</p>

<p>public String LargestPalindrome(String str)<br/>        {<br/>            int[] ar = new int[str.Length];<br/>            for (int i = 0; i  str.Length; i++)<br/>            {<br/>                int start = i;<br/>                for (int j = str.Length - 1; j = i; j--)<br/>                {<br/>                    int end = j;<br/>                    int cnt = 0;<br/>                    while (start = end)<br/>                    {<br/>                        if (str[start] == str[end])<br/>                        {<br/>                            if (start != end)<br/>                                cnt += 2;<br/>                            else<br/>                                cnt++;<br/>                            start++; end--;<br/>                        }<br/>                        else<br/>                        {<br/>                            cnt = 0;<br/>                            break;<br/>                        }                        <br/>                    }<br/>                    if (ar[i]  cnt)<br/>                        ar[i] = cnt;<br/>                }<br/>            }<br/>            int max = 0;<br/>            for (int i = 1; i  ar.Length; i++)<br/>            {<br/>                if (ar[i]  ar[max])<br/>                    max = i;<br/>            }</p>

<p>return str.Substring(max, ar[max]);<br/>        }<br/>}/prepre title=CodeMonkey63324 input=yes1<br/>2<br/>10<br/>42<br/>11</p>

<p>/pre</p>
		</li><li style="margin-left:15px;">
		<p>Complexity here is O(n^3).</p>
		</li><hr/><li>
		<p>int _tmain(int argc, _TCHAR* argv[])<br/>{<br/>	char p[500],*temp;<br/>	int i,j,str_len,k;<br/>	printf(\n Enter the string );<br/>	gets(p);<br/>	if (palendrome(p) == 0) {<br/>		printf(\n String is a palendrome);<br/>		return 1;<br/>	}<br/>	else<br/>		printf(\n Not a palendrome);<br/>	<br/>	str_len = strlen(p);<br/>	int largest_palindrome = 0;<br/>	char q[100];<br/>	for(i=0;istr_len;i++)<br/>	{<br/>		temp = p+i;<br/>		for(j=2;j=str_len-i;j++)<br/>		{<br/>			if(palendrome_substring(temp,j) == 0)<br/>			{<br/>				if (j  largest_palindrome){<br/>					largest_palindrome = j;<br/>					memcpy(q,temp,j);<br/>					q[j] = \0;<br/>				}<br/>			}<br/>		}<br/>	}<br/>	printf(\n largest palendrome %s,q);<br/>	return 0;<br/>}<br/>int palendrome(char *p)<br/>{<br/>	int str_len = 0,i;<br/>	if (!p ) return -1;<br/>	str_len = strlen(p);<br/>	if(str_len  2)return 1;<br/>	for(i=0;i(str_len/2);i++)<br/>	{<br/>		if (p[i] != p[str_len - i - 1])<br/>			return 1;<br/>	}<br/>	return 0;<br/>}</p>

<p>int palendrome_substring(char *p, int size)<br/>{<br/>	int str_len = 0,i;<br/>	if(!p || !size) return -1;<br/>		str_len = size;<br/>	for(i=0;i(str_len/2);i++) 	{<br/>		if (p[i] != p[str_len - i - 1])<br/>			return 1;<br/>	}<br/>	return 0;<br/>}</p>
		</li><hr/><li>
		<p><pre><br/>N^2 solution - Dynamic Programming. Should be good for interview.<br/>isPalindrome[i,j] = isPalindrome[i+1, j-1], if str[i] == str[j]<br/>                  = false, if str[i]!= str[j]<br/>                  = true,  if i == j //single character</p>

<p>After the matrix is filled, traverse diagonally to find the longest palindrome<br/></pre></p>

<p><pre><br/>#includestdio.h<br/>#includemalloc.h<br/>#includestring.h</p>

<p>int getLength(char* input)<br/>{<br/>	int len = 0;<br/>	while(*input)<br/>	{<br/>		len++;<br/>		input++;<br/>	}<br/>	return len;<br/>}</p>

<p>//O(n*n) DP solution<br/>void longestPalindrome(char* input)<br/>{<br/>	if(!input) return;<br/>	<br/>	int length = getLength(input);<br/>	<br/>	//Allocate a length*length table of boolean values<br/>	bool** DP = (bool**)malloc(length*sizeof(bool*));<br/>	for(int i = 0; i  length; i++)<br/>		DP[i] = (bool*)malloc(length*sizeof(bool));		<br/>	<br/>	int row = 0;<br/>	int col = 0;<br/>	int currCol = 0;<br/>	<br/>	//This loop traverse just the upper half of the matrix and populates it<br/>	while(col  length)<br/>	{<br/>		while(row  length  col  length)<br/>		{<br/>			if(row == col) DP[row][col] = true;<br/>			<br/>			else if(input[row] == input[col]) <br/>			{<br/>				//If they are adjacent chars and equal, then it is a palindrome<br/>				if(col == row+1) DP[row][col] = true;<br/>				//Check if the contained string is a palindrome<br/>				else             DP[row][col] = DP[row+1][col-1];<br/>			}<br/>			<br/>			else DP[row][col] = false;<br/>			row++;col++;<br/>		}<br/>		row = 0;<br/>		currCol++;<br/>		col = currCol;<br/>	}<br/>	<br/>	//Traverse the matrix diagonally to find the longest palindrome.<br/>	row = 0, col = 0, currCol = 0;<br/>	int maxi = 0;<br/>	int maxy = 0;<br/>	while(col  length)<br/>	{<br/>		while(row  length  col  length)<br/>		{<br/>			if(DP[row][col] == true) <br/>			{<br/>				maxi = row;<br/>				maxy = col;<br/>			}<br/>			row++; col++;<br/>		}<br/>		row = 0;<br/>		currCol++;<br/>		col = currCol;<br/>	}<br/>	<br/>	//maxi and maxy hold the beginning and ending of the longest palindrome<br/>	printf(Longest Palindrome is : );<br/>	while(maxi = maxy)<br/>	{<br/>		printf(%c, input[maxi]);<br/>		maxi++;<br/>	}<br/>	printf(\n);<br/>}</p>

<p>int main()<br/>{<br/>char input[] = mississippi;<br/>longestPalindrome(input);<br/>}<br/></pre></p>
		</li><li style="margin-left:15px;">
		<p><pre><br/>char * longPlaindrome (char *str)<br/>{<br/>	char * pointpal;<br/>	while(*str)<br/>	{int i=1;</p>

<p>if(*str==*(str+i)||*(str-i)==*(str+i))<br/>		{<br/>			if (*(str-i)==*(str+i))<br/>				pointpal=str-i;<br/>			else<br/>				pointpal=str;<br/>			i++;<br/>			while(*(str-(i-1))==*(str+i)||(*str-i)==*(str+i))<br/>			{<br/>				pointpal--;<br/>				i++;<br/>			}<br/>		}<br/>		str++;<br/>	}<br/>	return pointpal;<br/>}</p>

<p>int main()<br/>{<br/>	char * str1=ABMOCECXYYXOPQR;<br/>	char * longestpal=longPlaindrome(str1);<br/>	char * point=longestpal;<br/>	int loop=1;</p>

<p>while(loop)<br/>	{<br/>		cout*longestpal;<br/>		longestpal++;<br/>		if (point==longestpal)<br/>		{<br/>			loop=0;<br/>		}<br/>		if(*point==*longestpal)<br/>			point=longestpal+1;<br/>	}<br/>	coutendl;<br/>	return 1;<br/>}</p>

<p></pre></p>
		</li><hr/><li>
		<p><pre><br/>small change in previous program:</p>

<p>char * fndlong (char *str)<br/>{<br/>	char * pointpal, *longestpal;<br/>	int length, longest=0;<br/>	while(*str)<br/>	{int i=1;</p>

<p>if(*str==*(str+i)||*(str-i)==*(str+i))<br/>		{<br/>			if (*(str-i)==*(str+i))<br/>				pointpal=str-i;<br/>			else<br/>				pointpal=str;<br/>			i++;<br/>			length=0;<br/>			while(*(str-(i-1))==*(str+i)||(*str-i)==*(str+i))<br/>			{<br/>				pointpal--;<br/>				i++;<br/>				length=+ 2;<br/>			}<br/>		}<br/>		if(longest==0 || lengthlongest)<br/>		{	<br/>			longest=length;<br/>			longestpal=pointpal;<br/>		}<br/>		str++;<br/>	}<br/>	return longestpal;<br/>}</p>

<p>int main()<br/>{<br/>	char * str1=ABMABCDDCBAOCECXYYXOPQR;<br/>	char * longestpal=	fndlong(str1);<br/>	char * point=longestpal;<br/>	int loop=1;</p>

<p>while(loop)<br/>	{<br/>		cout*longestpal;<br/>		longestpal++;<br/>		if (point==longestpal)<br/>		{<br/>			loop=0;<br/>		}<br/>		if(*point==*longestpal)<br/>			point=longestpal+1;<br/>	}<br/>	coutendl;<br/>	return 1;<br/>}<br/></pre></p>
		</li><hr/><li>
		<p>I choose maintainability over performance until performance testing shows the code to be a bottleneck.</p>

<p><pre><br/>public string FindLongestPalindrome(string sInput)<br/>{<br/>  int i = 0;<br/>  int j = 0;<br/>  int k = 0;<br/>  int l = 0;<br/>  int lower=0;<br/>  int upper=0;<br/>  char [ ]input = sInput.ToCharArray();<br/>  int len = sInput.Length;</p>

<p>// Odd length Palindromes<br/>  while (i  len  j  len)<br/>  {<br/>    k = i;<br/>    l = j;<br/>    while ((k = 0  l  len)  (input [k] == input [l]))<br/>    {<br/>      if ((upper - lower) = (l - k))<br/>      {<br/>        lower = k;<br/>        upper = l;<br/>      }<br/>      k--;<br/>      l++;<br/>    }<br/>    i++;<br/>    j++;<br/>  }</p>

<p>// Even length Palindromes<br/>  i = 0;<br/>  j = 1;<br/>  while (i  len  j  len)<br/>  {<br/>    k = i;<br/>    l = j;<br/>    while ((k = 0  l  len)  (input [k] == input [l]))<br/>    {<br/>      if ((upper - lower) = (l - k))<br/>      {<br/>        lower = k;<br/>        upper = l;<br/>      }<br/>      k--;<br/>      l++;<br/>    }<br/>    i++;<br/>    j++;<br/>  }</p>

<p>return(sInput.Substring(lower, (upper-lower+1)));<br/>}<br/></pre></p>
		</li><hr/><li>
		<p>program to find longest palindrome:<br/>int main()<br/>{<br/>	int i,j,count=0,check=0,loc=0,pos=0;<br/>	string str;<br/>	coutenter stringendl;<br/>	cinstr;<br/>	for(i=1;istr.length();i++)<br/>	{<br/>		for(j=i;jstr.length();j++)<br/>		{<br/>			if(j-10 || j+1=str.length())<br/>				break;<br/>			if(str[j-1]==str[j+1])<br/>			{<br/>				count++;<br/>				loc=j;<br/>			}<br/>			else<br/>				break;<br/>		}<br/>		if (countcheck)<br/>		{<br/>			check=count;<br/>			pos=loc;<br/>		}<br/>	}<br/>	for(int k=(pos-check);k=(pos+check);k++)<br/>		coutstr[k];<br/>}</p>
		</li><hr/><li>
		<p>A very good O(n2) easy to follow code is available in<br/>technicalypto.com/2010/02/find-all-possible-palindromes-in-string</p>
		</li><hr/><li>
		<p><pre><br/>The idea is to go left and right from each element until left will be the beginning, or right will be the end.<br/>The initial length of each possible palindrome is 1.<br/>We need to distinguish 2 cases:</p>

<p>1). Odd case, like abcdcba<br/>2). Even case, like dcbaabcd</p>

<p>In even case, we need to shift our right pointer to one position right and to increasr the current length.</p>

<p>During each next move, we increase our current palindrome length on 2, if the left and the right characters are the same.<br/>When palindome stops (we reach the array borders, or our left and right characters are not the same any more),<br/>we compare our current palindrome length with the previous maximal length.</p>

<p>void FindLongestPalindrome(char Arr[])<br/>{<br/>	char* pCurr; // moving through our string<br/>	char* pBegin; // the beginning of the string<br/>	char* pEnd; // the end of the string<br/>	char* pLeft; // to go left from the current character<br/>	char*pRight; // to go right from the current character</p>

<p>int iMaxIndex=0;<br/>	int iCurIndex=0; <br/>	int iMaxLength=1;<br/>	int iLength;</p>

<p>pCurr=pBegin=Arr[0];<br/>	pEnd=pBegin;<br/>	<br/>	while(1)<br/>	{<br/>	pEnd++;<br/>	if(*pEnd==\0) break;<br/>	}<br/>    // now pEnd points to the end of our array</p>

<p>while(1) // go through the array<br/>	{<br/>		iLength=1;</p>

<p>//Odd case:<br/>		pLeft=pRight=pCurr;<br/>		//even case:<br/>		if((*pLeft)==(*pRight+1))<br/>		{<br/>			pRight++;<br/>			iLength++;<br/>			if(pRightpEnd) break;<br/>		}</p>

<p>while(1)<br/>		{<br/>           if((*pRight) != (*pLeft)) break;<br/>		   <br/>		   pLeft--;<br/>		   pRight++;<br/>		   if((pLeftpBegin) || (pRightpEnd)) break;</p>

<p>iLength = iLength+2; // because we add characters from the left and from the right<br/>		}</p>

<p>if(iLength  iMaxLength)<br/>		{<br/>           iMaxLength = iLength;<br/>		   iMaxIndex = iCurIndex;<br/>		}<br/>		<br/>		pCurr++;<br/>		if(pCurrpEnd) break;<br/>		iCurIndex++;<br/>	}</p>

<p>// Now we have iMaxIndex as the beginning of longest palindrome, and iMaxLength as its length<br/>    <br/>	for(int i=iMaxIndex; i=iMaxIndex+iMaxLength; i++)<br/>	printf(%c, Arr[i]);<br/>	printf(\n);<br/>}<br/></pre></p>
		</li><li style="margin-left:15px;">
		<p>nice !!!!</p>
		</li><hr/><li>
		<p>{{package mic01;</p>

<p>public class LongestPalindrome {</p>

<p>public static void main(String[] args) {<br/>		<br/>		String dummy = AAABBGFF ili ollo benmio ooloo eo sadkjansd evbnbve eikdo ooooooooookoooooooooo;<br/>		<br/>		System.out.println(letsDoThis(dummy));</p>

<p>}</p>

<p>private static String letsDoThis(String dummy) {<br/>		String result = null;<br/>		int max = 0;<br/>		String[] a = dummy.split( );<br/>		for(int i=0; ia.length; i++){<br/>			if(isPalindrome(a[i])){<br/>				if(a[i].length()  max)<br/>					result = a[i];<br/>			}<br/>		}<br/>		return result;<br/>	}</p>

<p>private static boolean isPalindrome(String string) {</p>

<p>int length = string.length();<br/>		if(length % 2 == 0)<br/>			return false;<br/>		else{<br/>			for(int i=0; ilength/2; i++){<br/>				if(string.charAt(i) != string.charAt(length-i-1)){<br/>					return false;<br/>				}<br/>			}<br/>		}	<br/>		return true;<br/>	}</p>

<p>}</p>

<p>}}</p>
		</li><hr/><li>
		<p>Reverse the string and compare using a shifting window.</p>

<p><pre><br/>def palindrome(string):<br/>     <br/>    Returns the longest palindrome in string.<br/>    <br/>    reverse = string[::-1]<br/>    winner = </p>

<p>if string == reverse:<br/>        return string</p>

<p>sources = [(string, reverse), (reverse, string)]</p>

<p>for source_a, source_b in sources:<br/>        for window in range(1, len(source_a) - 1): <br/>            string_a = source_a[:-window]<br/>            string_b = source_b[window:]</p>

<p>results = compare(string_a, string_b)<br/>            for result in results:<br/>                if len(result)  len(winner):<br/>                    print result<br/>                    winner = result</p>

<p>return winner</p>

<p>def compare(string_a, string_b):<br/>     <br/>    Compares two strings of equal length and finds any common strings between<br/>    the two.<br/>    <br/>    result = []<br/>    # True if a commonality is being extracted. This flag lets us know when to<br/>    # insert a new value into result.<br/>    found = False</p>

<p>for index in range(len(string_a)):<br/>        if string_a[index] == string_b[index]:<br/>            if not found:<br/>                result.append()<br/>                found = True<br/>            result[-1] += string_a[index]<br/>        else:<br/>            found = False</p>

<p>return result</p>

<p>print palindrome(zbbybab)<br/></pre></p>
		</li></ul>